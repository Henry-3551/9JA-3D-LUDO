<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #canvas-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            max-width: 800px;
            max-height: 800px;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .ui-panel {
            position: fixed;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #player-info {
            top: 20px;
            left: 20px;
            min-width: 200px;
        }

        #dice-panel {
            top: 20px;
            right: 20px;
            text-align: center;
        }

        #game-status {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
        }

        #rules-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 100;
        }

        #rules-button:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }

        .player-card {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 10px;
            transition: all 0.3s;
        }

        .player-card.active {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .player-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
            border: 3px solid white;
        }

        .player-name {
            font-weight: bold;
            font-size: 16px;
        }

        .player-pieces {
            margin-left: auto;
            font-size: 12px;
            opacity: 0.8;
        }

        #dice-container {
            display: flex;
            justify-content: center;
            gap: 50px;
            margin: 20px auto;
            perspective: 1000px;
            height: 80px;
            align-items: center;
        }

        .dice-cube {
            width: 60px;
            height: 60px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
        }

        .dice-cube.selected {
            box-shadow: 0 0 20px #ffff00;
            border-radius: 12px;
        }

        .dice-cube.used {
            opacity: 0.5;
            filter: grayscale(100%);
            cursor: default;
        }

        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: white;
            border: 1px solid #ccc;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        .dot {
            width: 10px;
            height: 10px;
            background: #333;
            border-radius: 50%;
            align-self: center;
            justify-self: center;
        }

        /* Face transforms */
        .front  { transform: translateZ(30px); }
        .back   { transform: rotateY(180deg) translateZ(30px); }
        .right  { transform: rotateY(90deg) translateZ(30px); }
        .left   { transform: rotateY(-90deg) translateZ(30px); }
        .top    { transform: rotateX(90deg) translateZ(30px); }
        .bottom { transform: rotateX(-90deg) translateZ(30px); }

        /* Dot positioning */
        .face-1 .dot:nth-child(1) { grid-area: 2 / 2; }

        .face-2 .dot:nth-child(1) { grid-area: 1 / 1; }
        .face-2 .dot:nth-child(2) { grid-area: 3 / 3; }

        .face-3 .dot:nth-child(1) { grid-area: 1 / 1; }
        .face-3 .dot:nth-child(2) { grid-area: 2 / 2; }
        .face-3 .dot:nth-child(3) { grid-area: 3 / 3; }

        .face-4 .dot:nth-child(1) { grid-area: 1 / 1; }
        .face-4 .dot:nth-child(2) { grid-area: 1 / 3; }
        .face-4 .dot:nth-child(3) { grid-area: 3 / 1; }
        .face-4 .dot:nth-child(4) { grid-area: 3 / 3; }

        .face-5 .dot:nth-child(1) { grid-area: 1 / 1; }
        .face-5 .dot:nth-child(2) { grid-area: 1 / 3; }
        .face-5 .dot:nth-child(3) { grid-area: 2 / 2; }
        .face-5 .dot:nth-child(4) { grid-area: 3 / 1; }
        .face-5 .dot:nth-child(5) { grid-area: 3 / 3; }

        .face-6 .dot:nth-child(1) { grid-area: 1 / 1; }
        .face-6 .dot:nth-child(2) { grid-area: 1 / 3; }
        .face-6 .dot:nth-child(3) { grid-area: 2 / 1; }
        .face-6 .dot:nth-child(4) { grid-area: 2 / 3; }
        .face-6 .dot:nth-child(5) { grid-area: 3 / 1; }
        .face-6 .dot:nth-child(6) { grid-area: 3 / 3; }

        @keyframes roll {
            0%, 100% { transform: rotateX(0) rotateY(0); }
            25% { transform: rotateX(180deg) rotateY(90deg); }
            50% { transform: rotateX(360deg) rotateY(180deg); }
            75% { transform: rotateX(180deg) rotateY(270deg); }
        }

        #roll-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        #roll-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.5);
        }

        #roll-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #status-text {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            color: #333;
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .modal-content h3 {
            color: #764ba2;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .modal-content li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .close-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }

        .close-button:hover {
            background: #764ba2;
        }

        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #start-screen.hidden {
            display: none;
        }

        #start-screen h1 {
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 0 5px 15px rgba(0,0,0,0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #start-screen p {
            font-size: 20px;
            margin-bottom: 40px;
            opacity: 0.9;
        }

        #start-button {
            background: white;
            color: #667eea;
            border: none;
            padding: 20px 60px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.4);
        }

        .player-select {
            margin: 20px 0;
        }

        .player-select label {
            font-size: 18px;
            margin-right: 10px;
        }

        .player-select select {
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            font-size: 16px;
            background: white;
            color: #667eea;
        }

        #winner-modal .modal-content {
            text-align: center;
        }

        #winner-modal h2 {
            font-size: 48px;
            margin-bottom: 30px;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #667eea;
            position: absolute;
            animation: confetti-fall 3s linear infinite;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>ðŸŽ² 3D LUDO ðŸŽ²</h1>
        <p>Experience the classic board game in stunning 3D!</p>
        <div class="player-select">
            <label for="num-players">Number of Players:</label>
            <select id="num-players">
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
                <option value="4" selected>4 Players</option>
            </select>
        </div>
        <button id="start-button">Start Game</button>
    </div>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>

        <div id="player-info" class="ui-panel">
            <h3 style="margin-bottom: 15px;">Players</h3>
            <div id="players-list"></div>
        </div>

        <div id="dice-panel" class="ui-panel" style="display: none;">
            <div id="dice-container">
                <div id="dice1" class="dice-cube">
                    <div class="face front face-1"><div class="dot"></div></div>
                    <div class="face back face-6"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face right face-2"><div class="dot"></div><div class="dot"></div></div>
                    <div class="face left face-5"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face top face-3"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face bottom face-4"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                </div>
                <div id="dice2" class="dice-cube">
                    <div class="face front face-1"><div class="dot"></div></div>
                    <div class="face back face-6"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face right face-2"><div class="dot"></div><div class="dot"></div></div>
                    <div class="face left face-5"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face top face-3"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                    <div class="face bottom face-4"><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
                </div>
            </div>
            <button id="roll-button">Roll Dice</button>
        </div>

        <div id="game-status" class="ui-panel">
            <div id="status-text">Click "Start Game" to begin!</div>
        </div>

        <button id="rules-button">ðŸ“– Rules</button>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <h2>ðŸŽ² Ludo Game Rules</h2>
            
            <h3>Objective</h3>
            <p>Be the first player to move all 4 of your pieces from your starting area to your home column.</p>
            
            <h3>How to Play</h3>
            <ul>
                <li><strong>Rolling the Dice:</strong> Click the "Roll Dice" button on your turn</li>
                <li><strong>Starting a Piece:</strong> Roll a 6 to move a piece from your starting area onto the board</li>
                <li><strong>Moving Pieces:</strong> Click on a piece to move it the number of spaces shown on the dice</li>
                <li><strong>Extra Turn:</strong> Rolling a 6 gives you an extra turn</li>
                <li><strong>Capturing:</strong> Landing on an opponent's piece sends it back to their starting area (and you roll again)</li>
                <li><strong>Safe Zones:</strong> Star spaces and starting squares are safe - pieces cannot be captured there</li>
                <li><strong>Home Column:</strong> Only your pieces can enter your colored home column</li>
                <li><strong>Winning:</strong> Get all 4 pieces to the center finish area to win!</li>
            </ul>
            
            <h3>Special Rules</h3>
            <ul>
                <li>You must roll the exact number to enter the finish area</li>
                <li>Three consecutive 6s in a row ends your turn without moving</li>
                <li>You cannot move if you have no valid moves available</li>
            </ul>
            
            <h3>Controls</h3>
            <ul>
                <li><strong>Mouse:</strong> Click and drag to rotate the board view</li>
                <li><strong>Scroll:</strong> Zoom in and out</li>
                <li><strong>Click Pieces:</strong> Select which piece to move</li>
            </ul>
            
            <button class="close-button" onclick="closeRules()">Got It!</button>
        </div>
    </div>

    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <h2>ðŸŽ‰ We Have a Winner! ðŸŽ‰</h2>
            <div id="winner-text" style="font-size: 24px; margin: 20px 0;"></div>
            <button class="close-button" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration (Standard Ludo layout)
        const PLAYERS = [
            { id: 0, name: 'Red', color: 0xff0000 },    // Top-Left
            { id: 1, name: 'Green', color: 0x00ff00 },  // Top-Right
            { id: 2, name: 'Yellow', color: 0xffff00 }, // Bottom-Right
            { id: 3, name: 'Blue', color: 0x0000ff }    // Bottom-Left
        ];

        // Board path definition (clockwise) - 52 squares total
        // Starting from Red's start square (1,6) and moving clockwise
        const BOARD_PATH = [
            // Red's path (Left Arm -> Top Arm)
            [1,6], [2,6], [3,6], [4,6], [5,6],          // 0-4: Left Arm Top Row
            [6,5], [6,4], [6,3], [6,2], [6,1], [6,0],   // 5-10: Top Arm Left Col
            [7,0], [8,0],                               // 11-12: Top End
            
            // Green's path (Top Arm -> Right Arm)
            [8,1], [8,2], [8,3], [8,4], [8,5],          // 13-17: Top Arm Right Col
            [9,6], [10,6], [11,6], [12,6], [13,6], [14,6], // 18-23: Right Arm Top Row
            [14,7], [14,8],                             // 24-25: Right End

            // Yellow's path (Right Arm -> Bottom Arm)
            [13,8], [12,8], [11,8], [10,8], [9,8],      // 26-30: Right Arm Bottom Row
            [8,9], [8,10], [8,11], [8,12], [8,13], [8,14], // 31-36: Bottom Arm Right Col
            [7,14], [6,14],                             // 37-38: Bottom End

            // Blue's path (Bottom Arm -> Left Arm)
            [6,13], [6,12], [6,11], [6,10], [6,9],      // 39-43: Bottom Arm Left Col
            [5,8], [4,8], [3,8], [2,8], [1,8], [0,8],   // 44-49: Left Arm Bottom Row
            [0,7], [0,6]                                // 50-51: Left End
        ];

        // Standard Ludo Layout:
        // Red (TL), Green (TR), Yellow (BR), Blue (BL)
        const START_SQUARES = [
            [1, 6],  // Red
            [8, 1],  // Green
            [13, 8], // Yellow
            [6, 13]  // Blue
        ];

        const coordKey = (x, z) => `${x},${z}`;
        const PATH_INDEX = new Map(BOARD_PATH.map(([x, z], i) => [coordKey(x, z), i]));
        const PLAYER_START_POSITIONS = START_SQUARES.map(([x, z]) => {
            const idx = PATH_INDEX.get(coordKey(x, z));
            if (idx === undefined) {
                throw new Error(`Start square ${x},${z} not found in BOARD_PATH`);
            }
            return idx;
        });

        // Home columns to center
        const HOME_PATHS = [
            [[1,7], [2,7], [3,7], [4,7], [5,7], [6,7]],     // Red (Left -> Center)
            [[7,1], [7,2], [7,3], [7,4], [7,5], [7,6]],     // Green (Top -> Center)
            [[13,7], [12,7], [11,7], [10,7], [9,7], [8,7]], // Yellow (Right -> Center)
            [[7,13], [7,12], [7,11], [7,10], [7,9], [7,8]]  // Blue (Bottom -> Center)
        ];

        // Safe squares (stars) - typically 8 squares from start
        const SAFE_POSITIONS = [
            [6,2],   // Top Arm
            [12,6],  // Right Arm
            [8,12],  // Bottom Arm
            [2,8]    // Left Arm
        ];

        const TRACK_LENGTH = 52;
        const HOME_LENGTH = 6;
        const HOME_POS_BASE = 1000;
        const FINISH_POS_BASE = 2000;

        // Movement direction: clockwise.
        // BOARD_PATH is now defined clockwise.
        const CLOCKWISE_STEP = 1; 

        // Home corner offsets in grid coords (x,z) for: Red, Green, Yellow, Blue
        const HOME_CORNER_OFFSETS = [
            [0, 0],  // Red (TL)
            [9, 0],  // Green (TR)
            [9, 9],  // Yellow (BR)
            [0, 9]   // Blue (BL)
        ];

        const HOME_CIRCLE_OFFSETS = [
            [1, 1], [4, 1], [1, 4], [4, 4]
        ];

        const START_SAFE_POSITIONS = PLAYER_START_POSITIONS.map((idx) => BOARD_PATH[idx]);

        // Game State
        let scene, camera, renderer, controls;
        let boardGroup, pieces = [];
        let currentPlayer = 0;
        let diceValues = [1, 1]; // Store both dice values
        let diceValue = 2;       // Total sum
        let selectedDieIndex = -1;
        let availableDiceIndices = [];
        let gameStarted = false;
        let numPlayers = 4;
        let activePlayers = [];
        let selectedPiece = null;
        let sixCount = 0;

        class GamePiece {
            constructor(playerId, pieceId) {
                this.playerId = playerId;
                this.pieceId = pieceId;
                this.position = -1; // -1 = in home, 0-51 = on track, 52+ = in finish column
                this.inFinish = false;
                this.mesh = null;
                this.homePosition = pieceId;
            }

            canMove(steps) {
                if (this.inFinish) return false;

                // Must roll 6 to bring a piece out
                if (this.position === -1) {
                    return steps === 6;
                }

                // In home column
                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    return homeIndex + steps <= HOME_LENGTH - 1;
                }

                // On main track
                if (this.position >= 0 && this.position < TRACK_LENGTH) {
                    const startIndex = PLAYER_START_POSITIONS[this.playerId];
                    // progress travelled clockwise from the start square
                    const progress = (this.position - startIndex + TRACK_LENGTH) % TRACK_LENGTH;
                    const target = progress + steps;

                    if (target < TRACK_LENGTH) return true;
                    const homeIndex = target - TRACK_LENGTH;
                    return homeIndex <= HOME_LENGTH - 1;
                }

                // Finished
                return false;
            }

            move(steps) {
                // Entering the board from home
                if (this.position === -1) {
                    // Place on start square
                    this.position = PLAYER_START_POSITIONS[this.playerId];
                    this.updateMeshPosition();
                    return;
                }

                this.moveOnTrack(steps);
            }

            moveOnTrack(steps) {
                // Move within home column
                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    const nextHomeIndex = homeIndex + steps;

                    if (nextHomeIndex === HOME_LENGTH - 1) {
                        this.inFinish = true;
                        this.position = FINISH_POS_BASE + (this.playerId * 10) + this.pieceId;
                    } else {
                        this.position = HOME_POS_BASE + (this.playerId * 10) + nextHomeIndex;
                    }

                    this.updateMeshPosition();
                    return;
                }

                // Move on main track
                const startIndex = PLAYER_START_POSITIONS[this.playerId];
                const progress = (this.position - startIndex + TRACK_LENGTH) % TRACK_LENGTH;
                const target = progress + steps;

                if (target < TRACK_LENGTH) {
                    // walk forwards along BOARD_PATH (since it is now clockwise)
                    this.position = (startIndex + target) % TRACK_LENGTH;
                } else {
                    const homeIndex = target - TRACK_LENGTH;
                    if (homeIndex === HOME_LENGTH - 1) {
                        this.inFinish = true;
                        this.position = FINISH_POS_BASE + (this.playerId * 10) + this.pieceId;
                    } else {
                        this.position = HOME_POS_BASE + (this.playerId * 10) + homeIndex;
                    }
                }

                this.updateMeshPosition();
            }

            getWorldPosition() {
                if (this.position === -1) {
                    // In home corner (on the 4 circles)
                    const [baseX, baseZ] = HOME_CORNER_OFFSETS[this.playerId];
                    const [dx, dz] = HOME_CIRCLE_OFFSETS[this.homePosition];
                    return [baseX + dx, baseZ + dz];
                }

                if (this.position >= FINISH_POS_BASE) {
                    // Finished: place in center with slight offsets
                    const angleOffset = (this.playerId * Math.PI / 2) + (this.pieceId * Math.PI / 8);
                    const radius = 0.35 + (this.pieceId * 0.18);
                    return [7 + Math.cos(angleOffset) * radius, 7 + Math.sin(angleOffset) * radius];
                }

                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    // In home column
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    return HOME_PATHS[this.playerId][homeIndex];
                } else {
                    // On main track (0-51)
                    return BOARD_PATH[this.position];
                }
            }

            updateMeshPosition() {
                if (!this.mesh) return;
                
                const [x, z] = this.getWorldPosition();
                const targetX = (x - 7) * 2;
                const targetZ = (z - 7) * 2;
                
                // Animate movement
                const startX = this.mesh.position.x;
                const startZ = this.mesh.position.z;
                const startY = this.mesh.position.y;
                
                let progress = 0;
                const animate = () => {
                    progress += 0.05;
                    if (progress <= 1) {
                        this.mesh.position.x = startX + (targetX - startX) * progress;
                        this.mesh.position.z = startZ + (targetZ - startZ) * progress;
                        this.mesh.position.y = startY + Math.sin(progress * Math.PI) * 2;
                        requestAnimationFrame(animate);
                    } else {
                        this.mesh.position.x = targetX;
                        this.mesh.position.z = targetZ;
                        this.mesh.position.y = 0.5;
                    }
                };
                animate();
            }
        }

        // Initialize Three.js
        function initThree() {
            const canvas = document.getElementById('game-canvas');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            
            camera = new THREE.PerspectiveCamera(
                45,
                1,
                0.1,
                1000
            );
            camera.position.set(0, 35, 35);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Simple orbit controls with mouse
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging && !selectedPiece) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    rotation.y += deltaX * 0.005;
                    rotation.x += deltaY * 0.005;
                    rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 6, rotation.x));
                    
                    camera.position.x = 35 * Math.sin(rotation.y) * Math.cos(rotation.x);
                    camera.position.y = 35 * Math.sin(rotation.x) + 20;
                    camera.position.z = 35 * Math.cos(rotation.y) * Math.cos(rotation.x);
                    camera.lookAt(0, 0, 0);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoom = e.deltaY * 0.01;
                const distance = camera.position.length();
                const newDistance = Math.max(20, Math.min(50, distance + zoom));
                camera.position.multiplyScalar(newDistance / distance);
            });
            
            createBoard();
            animate();
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            
            // Base board
            const boardGeometry = new THREE.BoxGeometry(30, 0.5, 30);
            const boardMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.receiveShadow = true;
            board.position.y = -0.25;
            boardGroup.add(board);

            // Wooden Frame
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b5a2b, // Wood color
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Top part
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(33, 1.5, 1.5), frameMaterial);
            frameTop.position.set(0, 0.25, -15.75);
            frameTop.castShadow = true;
            frameTop.receiveShadow = true;
            boardGroup.add(frameTop);

            // Bottom part
            const frameBottom = new THREE.Mesh(new THREE.BoxGeometry(33, 1.5, 1.5), frameMaterial);
            frameBottom.position.set(0, 0.25, 15.75);
            frameBottom.castShadow = true;
            frameBottom.receiveShadow = true;
            boardGroup.add(frameBottom);

            // Left part
            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 30), frameMaterial);
            frameLeft.position.set(-15.75, 0.25, 0);
            frameLeft.castShadow = true;
            frameLeft.receiveShadow = true;
            boardGroup.add(frameLeft);

            // Right part
            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 30), frameMaterial);
            frameRight.position.set(15.75, 0.25, 0);
            frameRight.castShadow = true;
            frameRight.receiveShadow = true;
            boardGroup.add(frameRight);

            const gridToWorld = (x, z) => ({
                wx: (x - 7) * 2,
                wz: (z - 7) * 2
            });

            const isHomeCorner = (x, z) =>
                (x <= 5 && z <= 5) ||
                (x <= 5 && z >= 9) ||
                (x >= 9 && z >= 9) ||
                (x >= 9 && z <= 5);

            // Solid home corner planes (remove internal grid lines in the colored corners)
            const textureLoader = new THREE.TextureLoader();
            const cornerPlane = new THREE.PlaneGeometry(12, 12);
            const imagePlane = new THREE.PlaneGeometry(11, 11); // Slightly smaller for padding

            const addCornerPlane = (centerX, centerZ, color, imagePath, rotation = 0) => {
                // Background color plane (padding)
                const mat = new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(cornerPlane, mat);
                plane.rotation.x = -Math.PI / 2;
                plane.position.set(centerX, 0.011, centerZ);
                boardGroup.add(plane);

                // Image plane
                if (imagePath) {
                    textureLoader.load(imagePath, (texture) => {
                        // Fix texture orientation if needed, or assume standard UVs
                        const imgMat = new THREE.MeshStandardMaterial({ 
                            map: texture, 
                            side: THREE.DoubleSide,
                            transparent: true
                        });
                        const imgMesh = new THREE.Mesh(imagePlane, imgMat);
                        imgMesh.rotation.x = -Math.PI / 2;
                        imgMesh.rotation.z = rotation; // Apply rotation to face the player
                        imgMesh.position.set(centerX, 0.012, centerZ); // Slightly higher than color plane
                        boardGroup.add(imgMesh);
                    }, undefined, (err) => {
                        console.error(`Error loading texture ${imagePath}:`, err);
                    });
                }
            };

            // Standard Ludo Layout: TL Red, TR Green, BR Yellow, BL Blue
            // Assigning images to corners with correct orientation for each player
            addCornerPlane(-9, -9, PLAYERS[0].color, 'osimhen.jpg', -Math.PI / 2); // Top-left Red (Faces Left)
            addCornerPlane( 9, -9, PLAYERS[1].color, 'musa.jpg', Math.PI);         // Top-right Green (Faces Top)
            addCornerPlane( 9,  9, PLAYERS[2].color, 'nwabali.jpg', Math.PI / 2);  // Bottom-right Yellow (Faces Right)
            addCornerPlane(-9,  9, PLAYERS[3].color, 'okocha.jpg', 0);             // Bottom-left Blue (Faces Bottom)

            // Draw home circles (4 per corner)
            const circleFillGeom = new THREE.CircleGeometry(0.78, 32);
            const ringGeom = new THREE.RingGeometry(0.55, 0.78, 32);
            const addHomeCircle = (gridX, gridZ, ringColor) => {
                const { wx, wz } = gridToWorld(gridX, gridZ);
                const fill = new THREE.Mesh(
                    circleFillGeom,
                    new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
                );
                fill.rotation.x = -Math.PI / 2;
                fill.position.set(wx, 0.02, wz);
                boardGroup.add(fill);

                const ring = new THREE.Mesh(
                    ringGeom,
                    new THREE.MeshStandardMaterial({ color: ringColor, side: THREE.DoubleSide })
                );
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(wx, 0.021, wz);
                boardGroup.add(ring);
            };

            // TL Red
            addHomeCircle(1, 1, PLAYERS[0].color);
            addHomeCircle(4, 1, PLAYERS[0].color);
            addHomeCircle(1, 4, PLAYERS[0].color);
            addHomeCircle(4, 4, PLAYERS[0].color);

            // TR Green
            addHomeCircle(10, 1, PLAYERS[1].color);
            addHomeCircle(13, 1, PLAYERS[1].color);
            addHomeCircle(10, 4, PLAYERS[1].color);
            addHomeCircle(13, 4, PLAYERS[1].color);

            // BR Yellow
            addHomeCircle(10, 10, PLAYERS[2].color);
            addHomeCircle(13, 10, PLAYERS[2].color);
            addHomeCircle(10, 13, PLAYERS[2].color);
            addHomeCircle(13, 13, PLAYERS[2].color);

            // BL Blue
            addHomeCircle(1, 10, PLAYERS[3].color);
            addHomeCircle(4, 10, PLAYERS[3].color);
            addHomeCircle(1, 13, PLAYERS[3].color);
            addHomeCircle(4, 13, PLAYERS[3].color);

            const pathIndexByKey = new Map(BOARD_PATH.map(([px, pz], i) => [coordKey(px, pz), i]));
            
            // Create grid squares
            for (let x = 0; x < 15; x++) {
                for (let z = 0; z < 15; z++) {
                    if (isHomeCorner(x, z)) continue; // corners are drawn as solid planes

                    const squareGeometry = new THREE.PlaneGeometry(1.8, 1.8);
                    let color = 0xeeeeee;
                    
                    // Main track
                    if (isOnPath(x, z)) {
                        color = 0xffffff;

                        const idx = pathIndexByKey.get(coordKey(x, z));
                        if (idx !== undefined) {
                            // Color the start squares
                            for (const playerId of [0, 1, 2, 3]) {
                                if (PLAYER_START_POSITIONS[playerId] === idx) {
                                    color = PLAYERS[playerId].color;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Color star safe spots (visual only)
                    if (isStarSpot(x, z)) {
                        if (color === 0xffffff) color = 0xdddddd;
                    }
                    
                    // Home columns
                    if (isHomeColumn(x, z)) {
                        if (x === 7 && z < 7) color = PLAYERS[1].color;      // Green Top
                        else if (z === 7 && x < 7) color = PLAYERS[0].color; // Red Left
                        else if (x === 7 && z > 7) color = PLAYERS[3].color; // Blue Bottom
                        else if (z === 7 && x > 7) color = PLAYERS[2].color; // Yellow Right
                    }
                    
                    const squareMaterial = new THREE.MeshStandardMaterial({ 
                        color,
                        side: THREE.DoubleSide
                    });
                    const square = new THREE.Mesh(squareGeometry, squareMaterial);
                    square.rotation.x = -Math.PI / 2;
                    square.position.set((x - 7) * 2, 0.01, (z - 7) * 2);
                    boardGroup.add(square);
                    
                    // Add border
                    const edges = new THREE.EdgesGeometry(squareGeometry);
                    const line = new THREE.LineSegments(
                        edges,
                        new THREE.LineBasicMaterial({ color: 0x333333 })
                    );
                    line.rotation.x = -Math.PI / 2;
                    line.position.set((x - 7) * 2, 0.02, (z - 7) * 2);
                    boardGroup.add(line);
                }
            }
            
            // Center finish area
            const finishGeometry = new THREE.BoxGeometry(6, 0.3, 6);
            const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
            
            textureLoader.load('MY_LOGO.png', (texture) => {
                finishMaterial.map = texture;
                finishMaterial.color = new THREE.Color(0xffffff);
                finishMaterial.needsUpdate = true;
            }, undefined, (err) => console.error('Error loading logo:', err));

            const finish = new THREE.Mesh(finishGeometry, finishMaterial);
            finish.position.set(0, 0.15, 0);
            boardGroup.add(finish);
            
            scene.add(boardGroup);
        }

        function isOnPath(x, z) {
            return BOARD_PATH.some(([px, pz]) => px === x && pz === z);
        }

        function isStarSpot(x, z) {
            return SAFE_POSITIONS.some(([px, pz]) => px === x && pz === z);
        }

        // Used for capture rules: stars are safe. Start squares are NOT safe (per user request).
        function isSafeSpot(x, z) {
            return isStarSpot(x, z);
        }

        function isHomeColumn(x, z) {
            return HOME_PATHS.some(path => 
                path.some(([px, pz]) => px === x && pz === z)
            );
        }

        function createPieces() {
            pieces = [];
            
            activePlayers.forEach(playerId => {
                const player = PLAYERS[playerId];
                
                for (let i = 0; i < 4; i++) {
                    const piece = new GamePiece(playerId, i);
                    
                    const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16);
                    const material = new THREE.MeshStandardMaterial({ color: player.color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.userData = { piece };
                    
                    const [x, z] = piece.getWorldPosition();
                    mesh.position.set((x - 7) * 2, 0.5, (z - 7) * 2);
                    
                    piece.mesh = mesh;
                    boardGroup.add(mesh);
                    pieces.push(piece);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Game Logic
        function startGame() {
            numPlayers = parseInt(document.getElementById('num-players').value);
            activePlayers = PLAYERS.slice(0, numPlayers).map(p => p.id);
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('dice-panel').style.display = 'block';
            
            createPieces();
            updatePlayersList();
            updateStatus(`${PLAYERS[currentPlayer].name}'s turn - Roll the dice!`);
            gameStarted = true;
            
            enableDiceRoll();
        }

        function updatePlayersList() {
            const list = document.getElementById('players-list');
            list.innerHTML = '';
            
            activePlayers.forEach(playerId => {
                const player = PLAYERS[playerId];
                const card = document.createElement('div');
                card.className = 'player-card';
                if (playerId === currentPlayer) card.classList.add('active');
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'player-color';
                colorDiv.style.background = `#${player.color.toString(16).padStart(6, '0')}`;
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name';
                nameDiv.textContent = player.name;
                
                const piecesDiv = document.createElement('div');
                piecesDiv.className = 'player-pieces';
                const finished = pieces.filter(p => p.playerId === playerId && p.inFinish).length;
                piecesDiv.textContent = `${finished}/4 finished`;
                
                card.appendChild(colorDiv);
                card.appendChild(nameDiv);
                card.appendChild(piecesDiv);
                list.appendChild(card);
            });
        }

        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
        }

        function enableDiceRoll() {
            const button = document.getElementById('roll-button');
            button.disabled = false;
            button.onclick = rollDice;
        }

        function disableDiceRoll() {
            const button = document.getElementById('roll-button');
            button.disabled = true;
            button.onclick = null;
        }

        let diceRotation = { d1: {x:0, y:0}, d2: {x:0, y:0} };

        function rollDice() {
            disableDiceRoll();
            
            const d1 = document.getElementById('dice1');
            const d2 = document.getElementById('dice2');
            
            // Random values
            const v1 = Math.floor(Math.random() * 6) + 1;
            const v2 = Math.floor(Math.random() * 6) + 1;
            
            diceValues = [v1, v2];
            diceValue = v1 + v2;

            // Calculate target rotation for each face
            // 1: 0,0 | 2: 0,-90 | 3: -90,0 | 4: 90,0 | 5: 0,90 | 6: 180,0
            const getRotation = (val) => {
                switch(val) {
                    case 1: return {x: 0, y: 0};
                    case 2: return {x: 0, y: -90};
                    case 3: return {x: -90, y: 0};
                    case 4: return {x: 90, y: 0};
                    case 5: return {x: 0, y: 90};
                    case 6: return {x: 180, y: 0};
                    default: return {x: 0, y: 0};
                }
            };

            const target1 = getRotation(v1);
            const target2 = getRotation(v2);

            // Add extra spins (multiple of 360) to ensure animation
            // We add to the current rotation to keep it continuous
            // Ensure we add at least 2 full spins (720deg)
            
            // Helper to find next multiple of 360 + target offset
            const nextRot = (current, target) => {
                const currentRot = current;
                // Add 2 to 4 full spins randomly
                const spins = (Math.floor(Math.random() * 3) + 2) * 360; 
                return currentRot + spins + (target - (currentRot % 360));
            };

            // We need to track accumulated rotation to prevent snapping back
            // But simpler approach: just add spins + target relative to 0, but keep increasing the base
            
            // Let's just add a large number of spins + the target offset
            // But we need to respect the current visual state.
            // Actually, since we are adding 360s, we can just add to the current value.
            
            // Fix: The target is absolute orientation. 
            // If current is 720, and target is 90. We want 720 + 360*n + 90.
            // But wait, if current is 720 (which is 0 mod 360), and we want 90.
            // We can just go to 720 + 720 + 90 = 1530.
            
            // We need to store the accumulated rotation in a variable outside
            
            // Update accumulated rotation
            // We add 720 (2 spins) + the difference to get to the target modulus
            
            const animateDice = (dieElem, currentRotObj, targetRotObj) => {
                // Add 720 to 1080 degrees of spin
                const spinX = (Math.floor(Math.random() * 2) + 2) * 360;
                const spinY = (Math.floor(Math.random() * 2) + 2) * 360;
                
                // We want the final rotation % 360 to equal targetRotObj
                // But since we use CSS rotateX/Y, the order matters. 
                // For a cube, simple X/Y rotations work if we align faces to axes.
                
                // Let's just simply add the spin and set the target.
                // To ensure we land correctly, we reset the "base" to 0 effectively by just adding to the previous total.
                // But we need to know "where is face N relative to 0,0".
                
                // Actually, simpler:
                // Just set the transform to the target + (N * 360).
                // Since we start at 0,0 (Face 1).
                // Next roll: Target Face 6 (180, 0). We set to (180 + 720, 0 + 720).
                // Next roll: Target Face 2 (0, -90). We set to (0 + 1440, -90 + 1440).
                // We just keep increasing the "spins" counter.
                
                currentRotObj.x += spinX;
                currentRotObj.y += spinY;
                
                // Adjust to match target face orientation
                // We need to replace the "remainder" with the target
                // Current: 720. Target: 90. Result: 720 + 90? No, 720 is 0.
                // We want the final value V such that V % 360 == target.
                // So we take the big spin number, add target.
                
                // Let's just use a simple incrementing base.
                // We don't need to be perfect with "current", just ensure it moves forward.
                
                // Resetting the "remainder" part of the rotation:
                // We want to keep the "thousands" part and replace the "hundreds" part.
                // But that's tricky with math.
                
                // Alternative: Just add the difference.
                // diffX = targetX - (currentX % 360).
                // If diffX < 0, diffX += 360.
                // newX = currentX + diffX + 720.
                
                let diffX = targetRotObj.x - (currentRotObj.x % 360);
                if (diffX < -180) diffX += 360;
                if (diffX > 180) diffX -= 360;
                // Ensure we always spin forward a bit? 
                // Actually, just adding 720 + diff works well.
                
                // We need to ensure we don't just wiggle.
                // Let's force at least 2 spins.
                
                const moveX = 720 + targetRotObj.x - (currentRotObj.x % 360);
                const moveY = 720 + targetRotObj.y - (currentRotObj.y % 360);
                
                currentRotObj.x += moveX;
                currentRotObj.y += moveY;
                
                dieElem.style.transform = `rotateX(${currentRotObj.x}deg) rotateY(${currentRotObj.y}deg)`;
            };

            animateDice(d1, diceRotation.d1, target1);
            animateDice(d2, diceRotation.d2, target2);
            
            setTimeout(() => {
                handleDiceRoll();
            }, 1000); // Wait for animation (1s)
        }

        let currentPieceClickListener = null;

        function selectDie(index) {
            if (!availableDiceIndices.includes(index)) return;
            
            selectedDieIndex = index;
            const val = diceValues[index];
            
            // Highlight selected die
            document.getElementById('dice1').classList.remove('selected');
            document.getElementById('dice2').classList.remove('selected');
            document.getElementById(index === 0 ? 'dice1' : 'dice2').classList.add('selected');
            
            updateStatus(`${PLAYERS[currentPlayer].name} selected ${val} - Select a piece to move`);
            
            const playerPieces = pieces.filter(p => p.playerId === currentPlayer);
            const movablePieces = playerPieces.filter(p => p.canMove(val));
            
            // Reset highlighting
            pieces.forEach(p => {
                if (p.mesh) {
                    p.mesh.material.emissive = new THREE.Color(0x000000);
                    p.mesh.material.emissiveIntensity = 0;
                }
            });
            
            if (movablePieces.length > 0) {
                movablePieces.forEach(piece => {
                    piece.mesh.material.emissive = new THREE.Color(0x444444);
                    piece.mesh.material.emissiveIntensity = 0.5;
                });
                enablePieceSelection(movablePieces);
            } else {
                updateStatus(`No moves for ${val}. Select other die.`);
                // If only one die left and no moves, turn ends.
                if (availableDiceIndices.length === 1) {
                     setTimeout(() => finishTurn(false), 1500);
                }
            }
        }

        function handleDiceRoll() {
            const rolledSix = diceValues.includes(6);

            if (rolledSix) {
                sixCount++;
                if (sixCount >= 3) {
                    updateStatus(`${PLAYERS[currentPlayer].name} rolled three 6s! Turn skipped.`);
                    setTimeout(() => nextTurn(), 1500);
                    return;
                }
            } else {
                sixCount = 0;
            }
            
            availableDiceIndices = [0, 1];
            
            // Reset dice visuals
            const d1 = document.getElementById('dice1');
            const d2 = document.getElementById('dice2');
            d1.classList.remove('selected', 'used');
            d2.classList.remove('selected', 'used');
            
            // Make dice clickable
            d1.onclick = () => selectDie(0);
            d2.onclick = () => selectDie(1);
            
            const playerPieces = pieces.filter(p => p.playerId === currentPlayer);
            
            // Check if any moves are possible at all
            const canMoveAny = availableDiceIndices.some(idx => 
                playerPieces.some(p => p.canMove(diceValues[idx]))
            );
            
            if (!canMoveAny) {
                updateStatus(`${PLAYERS[currentPlayer].name} has no valid moves!`);
                setTimeout(() => nextTurn(), 1500);
                return;
            }
            
            updateStatus(`${PLAYERS[currentPlayer].name} rolled ${diceValues[0]} & ${diceValues[1]} - Select a die`);
            
            // Auto-select first die if it has moves
            if (playerPieces.some(p => p.canMove(diceValues[0]))) {
                selectDie(0);
            } else if (playerPieces.some(p => p.canMove(diceValues[1]))) {
                selectDie(1);
            }
        }

        function enablePieceSelection(movablePieces) {
            const canvas = document.getElementById('game-canvas');
            
            if (currentPieceClickListener) {
                canvas.removeEventListener('click', currentPieceClickListener);
            }

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            currentPieceClickListener = function(event) {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(
                    movablePieces.map(p => p.mesh)
                );
                
                if (intersects.length > 0) {
                    const piece = intersects[0].object.userData.piece;
                    selectPiece(piece, diceValues[selectedDieIndex]);
                    canvas.removeEventListener('click', currentPieceClickListener);
                    currentPieceClickListener = null;
                }
            };
            
            canvas.addEventListener('click', currentPieceClickListener);
        }

        function selectPiece(piece, steps) {
            // Remove highlighting
            pieces.forEach(p => {
                if (p.mesh) {
                    p.mesh.material.emissive = new THREE.Color(0x000000);
                    p.mesh.material.emissiveIntensity = 0;
                }
            });
            
            const oldPosition = piece.position;
            piece.move(steps);

            let capturedThisMove = false;
            
            // Check for capture
            if (piece.position >= 0 && piece.position < TRACK_LENGTH) {
                const [x, z] = piece.getWorldPosition();

                if (!isSafeSpot(x, z)) {
                    const capturedPiece = pieces.find(p =>
                        p !== piece &&
                        p.playerId !== piece.playerId &&
                        p.position === piece.position &&
                        p.position >= 0 &&
                        p.position < TRACK_LENGTH
                    );

                    if (capturedPiece) {
                        capturedPiece.position = -1;
                        capturedPiece.inFinish = false;
                        capturedPiece.updateMeshPosition();
                        capturedThisMove = true;
                        updateStatus(`${PLAYERS[currentPlayer].name} captured ${PLAYERS[capturedPiece.playerId].name}'s piece!`);
                    }
                }
            }
            
            // Mark die as used
            availableDiceIndices = availableDiceIndices.filter(i => i !== selectedDieIndex);
            const usedDieElem = document.getElementById(selectedDieIndex === 0 ? 'dice1' : 'dice2');
            usedDieElem.classList.remove('selected');
            usedDieElem.classList.add('used');
            usedDieElem.onclick = null; // Disable click
            
            updateAllPiecePositions(); // Update visual offsets for overlaps

            setTimeout(() => {
                checkWin();

                // If more dice available, continue turn
                if (availableDiceIndices.length > 0) {
                    const remainingIndex = availableDiceIndices[0];
                    const remainingValue = diceValues[remainingIndex];
                    
                    // Check if remaining die has valid moves
                    const playerPieces = pieces.filter(p => p.playerId === currentPlayer);
                    const canMoveRemaining = playerPieces.some(p => p.canMove(remainingValue));
                    
                    if (canMoveRemaining) {
                        updateStatus(`${PLAYERS[currentPlayer].name} - Auto-selecting remaining die (${remainingValue})`);
                        // Auto-select the remaining die for smoother gameplay
                        selectDie(remainingIndex);
                    } else {
                        updateStatus(`No moves for remaining die (${remainingValue}). Turn ending.`);
                        setTimeout(() => finishTurn(capturedThisMove), 1500);
                    }
                } else {
                    finishTurn(capturedThisMove);
                }
            }, 600);
        }

        function finishTurn(capturedThisMove) {
            const rolledSix = diceValues.includes(6);
            const bonusTurn = (rolledSix && sixCount < 3) || capturedThisMove;

            if (bonusTurn) {
                if (rolledSix && capturedThisMove) {
                    updateStatus(`${PLAYERS[currentPlayer].name} rolled a 6 and captured! Roll again!`);
                } else if (rolledSix) {
                    updateStatus(`${PLAYERS[currentPlayer].name} rolled a 6! Roll again!`);
                } else {
                    updateStatus(`${PLAYERS[currentPlayer].name} captured! Roll again!`);
                }
                
                // Reset dice visuals for next roll
                const d1 = document.getElementById('dice1');
                const d2 = document.getElementById('dice2');
                if(d1) d1.classList.remove('selected', 'used');
                if(d2) d2.classList.remove('selected', 'used');
                
                enableDiceRoll();
            } else {
                nextTurn();
            }
        }

        function nextTurn() {
            sixCount = 0;
            const currentIndex = activePlayers.indexOf(currentPlayer);
            currentPlayer = activePlayers[(currentIndex + 1) % activePlayers.length];
            
            updatePlayersList();
            updateStatus(`${PLAYERS[currentPlayer].name}'s turn - Roll the dice!`);
            enableDiceRoll();
        }

        function checkWin() {
            const playerPieces = pieces.filter(p => p.playerId === currentPlayer);
            const finishedPieces = playerPieces.filter(p => p.inFinish);
            
            if (finishedPieces.length === 4) {
                showWinner();
            }
            
            updatePlayersList();
        }

        function showWinner() {
            const modal = document.getElementById('winner-modal');
            const text = document.getElementById('winner-text');
            text.textContent = `${PLAYERS[currentPlayer].name} Player Wins!`;
            text.style.color = `#${PLAYERS[currentPlayer].color.toString(16).padStart(6, '0')}`;
            modal.classList.add('show');
            
            // Add confetti
            for (let i = 0; i < 50; i++) {
                setTimeout(() => createConfetti(), i * 50);
            }
        }

        function createConfetti() {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.background = `hsl(${Math.random() * 360}, 70%, 50%)`;
            confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
            document.body.appendChild(confetti);
            
            setTimeout(() => confetti.remove(), 3000);
        }

        function restartGame() {
            location.reload();
        }

        function closeRules() {
            document.getElementById('rules-modal').classList.remove('show');
        }

        // Event Listeners
        document.getElementById('start-button').addEventListener('click', startGame);
        document.getElementById('rules-button').addEventListener('click', () => {
            document.getElementById('rules-modal').classList.add('show');
        });

        // Initialize
        initThree();
    </script>
</body>
</html>

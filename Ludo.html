<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Ludo Game - 9JA Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #006400 0%, #ffffff 50%, #006400 100%); /* Nigeria Green-White-Green */
            overflow: hidden;
            color: white;
            touch-action: none;
        }
        #game-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; position: relative; }
        #canvas-container { position: relative; width: 100vw; height: 100vh; max-width: none; max-height: none; }
        #game-canvas { width: 100%; height: 100%; display: block; }
        .ui-panel {
            position: fixed; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px);
            border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); pointer-events: auto;
        }
        
        /* Desktop Positions */
        #player-info { top: 20px; left: 20px; min-width: 200px; max-height: 40vh; overflow-y: auto; }
        #dice-panel { bottom: 80px; left: 50%; transform: translateX(-50%); text-align: center; min-width: 200px; }
        #game-status { bottom: 20px; left: 50%; transform: translateX(-50%); padding: 15px 30px; width: auto; text-align: center; background: rgba(0,0,0,0.9); border: 1px solid #555; }
        
        #rules-button {
            position: fixed; top: 20px; right: 20px;
            background: rgba(255,255,255,0.2); border: 2px solid white; color: white;
            padding: 10px 20px; border-radius: 25px; cursor: pointer;
            font-size: 14px; transition: all 0.3s; z-index: 100;
        }
        #rules-button:hover { background: rgba(255,255,255,0.4); transform: scale(1.05); }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            #player-info { top: 10px; left: 10px; padding: 10px; min-width: 120px; transform: scale(0.8); transform-origin: top left; }
            .player-pieces { display: none; }
            #dice-panel { bottom: 70px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 350px; display: flex; flex-direction: column; align-items: center; padding: 10px; }
            #dice-container { margin: 10px 0; gap: 30px; transform: scale(0.8); }
            #game-status { bottom: 10px; width: 95%; font-size: 14px; padding: 10px; }
            #rules-button { top: 10px; right: 10px; padding: 5px 10px; font-size: 12px; }
            #start-screen h1 { font-size: 40px; }
            #start-button { padding: 15px 40px; font-size: 20px; }
        }
        /* UI Elements */
        .player-card { display: flex; align-items: center; margin: 10px 0; padding: 10px; border-radius: 10px; transition: all 0.3s; }
        .player-card.active { background: rgba(255,255,255,0.2); transform: scale(1.05); border: 1px solid rgba(255,255,255,0.3); }
        .player-color { width: 30px; height: 30px; border-radius: 50%; margin-right: 10px; border: 3px solid white; }
        .player-name { font-weight: bold; font-size: 16px; }
        .player-pieces { margin-left: auto; font-size: 12px; opacity: 0.8; }
        
        #dice-container { display: none; } /* Hidden because dice are now 3D on the board */
        
        #roll-button { background: linear-gradient(135deg, #008751 0%, #2e8b57 100%); border: none; color: white; padding: 12px 30px; border-radius: 25px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s; margin-top: 10px; width: 100%; }
        #roll-button:disabled { opacity: 0.5; cursor: not-allowed; }
        #status-text { font-size: 18px; font-weight: bold; text-align: center; }
        
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal.show { display: flex; }
        .modal-content { background: white; color: #333; padding: 40px; border-radius: 20px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5); width: 90%; }
        .modal-content h2 { color: #006400; margin-bottom: 20px; }
        .close-button { background: #006400; color: white; border: none; padding: 10px 30px; border-radius: 25px; cursor: pointer; font-size: 16px; margin-top: 20px; }
        
        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #004d00 0%, #008751 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; }
        #start-screen.hidden { display: none; }
        #start-screen h1 { font-size: 72px; margin-bottom: 20px; text-shadow: 0 5px 15px rgba(0,0,0,0.3); animation: pulse 2s infinite; text-align: center; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        #start-screen p { font-size: 20px; margin-bottom: 40px; opacity: 0.9; text-align: center; }
        #start-button { background: white; color: #006400; border: none; padding: 20px 60px; border-radius: 50px; font-size: 24px; font-weight: bold; cursor: pointer; transition: all 0.3s; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .player-select { margin: 20px 0; }
        .player-select select { padding: 10px 20px; border-radius: 10px; border: none; font-size: 16px; }
        
        .confetti { position: fixed; width: 10px; height: 10px; background: #667eea; animation: confetti-fall 3s linear infinite; pointer-events: none; }
        @keyframes confetti-fall { to { transform: translateY(100vh) rotate(360deg); opacity: 0; } }
        
        @keyframes boardSlideIn {
            0% { transform: translateY(-200px) rotateX(90deg); opacity: 0; }
            60% { transform: translateY(10px) rotateX(-5deg); opacity: 1; }
            100% { transform: translateY(0) rotateX(0deg); opacity: 1; }
        }
        
        @keyframes piecePopIn {
            0% { transform: scale(0) translateY(-50px); opacity: 0; }
            50% { transform: scale(1.2) translateY(-10px); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
    </style>
</head>

<body>
    <div id="start-screen">
        <h1>üé≤ 9JA LUDO üé≤</h1>
        <p>Experience the classic board game in stunning 3D!üëåüèæ</p>
        <div class="player-select">
            <label for="num-players">Select Number of Players:</label>
            <select id="num-players">
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
                <option value="4" selected>4 Players</option>
            </select>
        </div>
        <button id="start-button">Start Game</button>
    </div>

    <div id="game-container">
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>
        </div>
        <div id="player-info" class="ui-panel">
            <h3 style="margin-bottom: 15px;">Players</h3>
            <div id="players-list"></div>
        </div>
        <div id="dice-panel" class="ui-panel" style="display: none;">
            <button id="roll-button">Roll Dice</button>
        </div>
        <div id="game-status" class="ui-panel"><div id="status-text">Ready?</div></div>
        <button id="rules-button">üìñ Rules</button>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <h2>üìú 9JA Ludo Rules</h2>
            <ul style="text-align: left; line-height: 1.6;">
                <li><strong>Start:</strong> Only a <strong>6</strong> brings a piece out.</li>
                <li><strong>Bonus Turn:</strong> You ONLY roll again if you get <strong>6-6</strong> or <strong>Capture</strong> an opponent.</li>
                <li><strong>Killer Retires:</strong> If you capture an opponent, your piece goes straight to WIN (Center)!</li>
                <li><strong>Safety:</strong> NO safe zones on the track. Only Home Column is safe.</li>
            </ul>
            <button class="close-button" onclick="closeRules()">Oya Let's Play!</button>
        </div>
    </div>
    
    <div id="winner-modal" class="modal">
        <div class="modal-content">
            <h2>üéâ We Have a Winner! üéâ</h2>
            <div id="winner-text" style="font-size: 24px; margin: 20px 0;"></div>
            <button class="close-button" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const PLAYERS = [{ id: 0, name: 'Red', color: 0xff0000 }, { id: 1, name: 'Green', color: 0x00ff00 }, { id: 2, name: 'Yellow', color: 0xffff00 }, { id: 3, name: 'Blue', color: 0x0000ff }];
        const BOARD_PATH = [[1,6], [2,6], [3,6], [4,6], [5,6], [6,5], [6,4], [6,3], [6,2], [6,1], [6,0], [7,0], [8,0], [8,1], [8,2], [8,3], [8,4], [8,5], [9,6], [10,6], [11,6], [12,6], [13,6], [14,6], [14,7], [14,8], [13,8], [12,8], [11,8], [10,8], [9,8], [8,9], [8,10], [8,11], [8,12], [8,13], [8,14], [7,14], [6,14], [6,13], [6,12], [6,11], [6,10], [6,9], [5,8], [4,8], [3,8], [2,8], [1,8], [0,8], [0,7], [0,6]];
        const START_SQUARES = [[1, 6], [8, 1], [13, 8], [6, 13]];
        const coordKey = (x, z) => `${x},${z}`;
        const PATH_INDEX = new Map(BOARD_PATH.map(([x, z], i) => [coordKey(x, z), i]));
        const PLAYER_START_POSITIONS = START_SQUARES.map(([x, z]) => PATH_INDEX.get(coordKey(x, z)));
        const HOME_PATHS = [[[1,7], [2,7], [3,7], [4,7], [5,7], [6,7]], [[7,1], [7,2], [7,3], [7,4], [7,5], [7,6]], [[13,7], [12,7], [11,7], [10,7], [9,7], [8,7]], [[7,13], [7,12], [7,11], [7,10], [7,9], [7,8]]];
        const SAFE_POSITIONS = []; 
        const TRACK_LENGTH = 52;
        const HOME_LENGTH = 6;
        const HOME_POS_BASE = 1000;
        const FINISH_POS_BASE = 2000;
        const HOME_CORNER_OFFSETS = [[0, 0], [9, 0], [9, 9], [0, 9]];
        const HOME_CIRCLE_OFFSETS = [[1, 1], [4, 1], [1, 4], [4, 4]];

        let scene, camera, renderer;
        let boardGroup, pieces = [], diceMeshes = [];
        let currentPlayer = 0;
        let diceValues = [1, 1];
        let availableDiceIndices = [];
        let activePlayers = [];
        let selectedDieIndex = -1;
        let currentPieceClickListener = null;
        let currentZoom = 35; 
        let rotation = { x: 0, y: 0 };
        const MIN_ZOOM = 15; 
        const MAX_ZOOM = 70;
        
        // 3D Selection System
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredPiece = null;
        let selectablePieces = [];
        let selectedPiece = null;

        // Sound Effects System
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const playSound = {
            diceRoll: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            },
            pieceMove: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            capture: () => {
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(audioCtx.destination);
                osc1.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
                osc2.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc1.start();
                osc2.start();
                osc1.stop(audioCtx.currentTime + 0.3);
                osc2.stop(audioCtx.currentTime + 0.3);
            },
            win: () => {
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.frequency.value = freq;
                        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.3);
                    }, i * 100);
                });
            },
            click: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            },
            bonus: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        };

        class GamePiece {
            constructor(playerId, pieceId) {
                this.playerId = playerId; this.pieceId = pieceId; this.position = -1; this.inFinish = false; this.mesh = null; this.homePosition = pieceId;
            }
            canMove(steps) {
                if (this.inFinish) return false;
                if (this.position === -1) return steps === 6; 
                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    return homeIndex + steps <= HOME_LENGTH - 1;
                }
                if (this.position >= 0 && this.position < TRACK_LENGTH) {
                    const startIndex = PLAYER_START_POSITIONS[this.playerId];
                    const progress = (this.position - startIndex + TRACK_LENGTH) % TRACK_LENGTH;
                    const target = progress + steps;
                    if (target < TRACK_LENGTH) return true;
                    const homeIndex = target - TRACK_LENGTH;
                    return homeIndex <= HOME_LENGTH - 1;
                }
                return false;
            }
            move(steps) {
                if (this.position === -1) { this.position = PLAYER_START_POSITIONS[this.playerId]; }
                else { this.moveOnTrack(steps); }
                this.updateMeshPosition();
            }
            moveOnTrack(steps) {
                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    const nextHomeIndex = homeIndex + steps;
                    if (nextHomeIndex === HOME_LENGTH - 1) { this.inFinish = true; this.position = FINISH_POS_BASE + (this.playerId * 10) + this.pieceId; }
                    else { this.position = HOME_POS_BASE + (this.playerId * 10) + nextHomeIndex; }
                    return;
                }
                const startIndex = PLAYER_START_POSITIONS[this.playerId];
                const progress = (this.position - startIndex + TRACK_LENGTH) % TRACK_LENGTH;
                const target = progress + steps;
                if (target < TRACK_LENGTH) { this.position = (startIndex + target) % TRACK_LENGTH; }
                else {
                    const homeIndex = target - TRACK_LENGTH;
                    if (homeIndex === HOME_LENGTH - 1) { this.inFinish = true; this.position = FINISH_POS_BASE + (this.playerId * 10) + this.pieceId; }
                    else { this.position = HOME_POS_BASE + (this.playerId * 10) + homeIndex; }
                }
            }
            getWorldPosition() {
                if (this.position === -1) {
                    const [baseX, baseZ] = HOME_CORNER_OFFSETS[this.playerId];
                    const [dx, dz] = HOME_CIRCLE_OFFSETS[this.homePosition];
                    return [baseX + dx, baseZ + dz];
                }
                if (this.position >= FINISH_POS_BASE) {
                    const angleOffset = (this.playerId * Math.PI / 2) + (this.pieceId * Math.PI / 8);
                    const radius = 0.35 + (this.pieceId * 0.18);
                    return [7 + Math.cos(angleOffset) * radius, 7 + Math.sin(angleOffset) * radius];
                }
                if (this.position >= HOME_POS_BASE && this.position < FINISH_POS_BASE) {
                    const homeIndex = this.position - HOME_POS_BASE - (this.playerId * 10);
                    return HOME_PATHS[this.playerId][homeIndex];
                }
                return BOARD_PATH[this.position];
            }
            updateMeshPosition() {
                if (!this.mesh) return;
                const [x, z] = this.getWorldPosition();
                const targetX = (x - 7) * 2; const targetZ = (z - 7) * 2;
                const startX = this.mesh.position.x; const startZ = this.mesh.position.z; const startY = this.mesh.position.y;
                let progress = 0;
                const animate = () => {
                    progress += 0.05;
                    if (progress <= 1) {
                        this.mesh.position.set(startX + (targetX - startX) * progress, startY + Math.sin(progress * Math.PI) * 2, startZ + (targetZ - startZ) * progress);
                        requestAnimationFrame(animate);
                    } else {
                        this.mesh.position.set(targetX, 0.5, targetZ);
                    }
                };
                animate();
            }
            setHighlight(state) {
                if (!this.mesh) return;
                if (state === 'selectable') {
                    this.mesh.material.emissive.setHex(0x444444);
                    this.mesh.material.emissiveIntensity = 0.5;
                } else if (state === 'hover') {
                    this.mesh.material.emissive.setHex(0x888888);
                    this.mesh.material.emissiveIntensity = 0.8;
                } else if (state === 'selected') {
                    this.mesh.material.emissive.setHex(0xffffff);
                    this.mesh.material.emissiveIntensity = 1.0;
                } else {
                    this.mesh.material.emissive.setHex(0x000000);
                    this.mesh.material.emissiveIntensity = 0;
                }
            }
        }
        function initThree() {
            const canvas = document.getElementById('game-canvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x008751);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(10, 20, 10); dl.castShadow = true; scene.add(dl);
            let isDragging = false, previousPos = { x: 0, y: 0 }, initialPinchDist = 0;
            const getEventPos = (e) => (e.touches && e.touches.length > 0) ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
            const onStart = (e) => {
                if (e.target.closest('.ui-panel') || e.target.closest('button')) return;
                if (e.touches && e.touches.length === 2) {
                    isDragging = false;
                    initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                } else {
                    isDragging = true; previousPos = getEventPos(e);
                }
            };
            const onMove = (e) => {
                if (e.touches && e.touches.length === 2) {
                    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    currentZoom += (initialPinchDist - d) * 0.1; initialPinchDist = d;
                    currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom)); updateCameraPosition(); return;
                }
                if (isDragging) {
                    const pos = getEventPos(e);
                    rotation.y += (pos.x - previousPos.x) * 0.005; rotation.x += (pos.y - previousPos.y) * 0.005;
                    rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 6, rotation.x));
                    updateCameraPosition(); previousPos = pos;
                }
            };
            canvas.addEventListener('wheel', (e) => { e.preventDefault(); currentZoom += e.deltaY * 0.05; currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom)); updateCameraPosition(); }, { passive: false });
            canvas.addEventListener('mousedown', onStart); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', () => isDragging = false);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); }, { passive: false });
            window.addEventListener('touchmove', (e) => { if(isDragging || e.touches.length === 2) e.preventDefault(); onMove(e); }, { passive: false });
            window.addEventListener('touchend', () => isDragging = false);
            
            // 3D Selection: Track mouse/touch for raycasting
            const updateMousePosition = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            };
            
            canvas.addEventListener('mousemove', updateMousePosition);
            canvas.addEventListener('touchmove', (e) => { if (e.touches.length === 1) updateMousePosition(e); }, { passive: true });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            createBoard();
            createDiceMeshes();
            animate();
        }
        function updateCameraPosition() {
            camera.position.set(currentZoom * Math.sin(rotation.y) * Math.cos(rotation.x), currentZoom * Math.sin(rotation.x) + (currentZoom * 0.6), currentZoom * Math.cos(rotation.y) * Math.cos(rotation.x));
            camera.lookAt(0, 0, 0);
        }

        // --- NEW: Texture Generator for Dice Faces ---
        function createDieFaceTexture(value, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#ccc'; ctx.lineWidth = 4; ctx.strokeRect(0, 0, 128, 128);
            
            const dotSize = value === 1 ? 35 : 14; // Big dot for 1
            const dotColor = value === 1 ? 'red' : 'black'; // Red dot for 1

            ctx.fillStyle = dotColor;
            const drawDot = (x, y) => { ctx.beginPath(); ctx.arc(x, y, dotSize, 0, Math.PI * 2); ctx.fill(); };
            
            const c = 64, q1 = 32, q3 = 96;
            if (value % 2 === 1) drawDot(c, c);
            if (value > 1) { drawDot(q1, q1); drawDot(q3, q3); }
            if (value > 3) { drawDot(q1, q3); drawDot(q3, q1); }
            if (value === 6) { drawDot(q1, c); drawDot(q3, c); }
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- UPDATED: Create Dice with Textures ---
        function createDiceMeshes() {
            const diceGeom = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            // Material Order: Right(1), Left(6), Top(2), Bottom(5), Front(3), Back(4)
            const materials = [
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(1) }),
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(6) }),
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(2) }),
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(5) }),
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(3) }),
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(4) })
            ];

            for(let i = 0; i < 2; i++) {
                const mesh = new THREE.Mesh(diceGeom, materials);
                mesh.position.set(i === 0 ? -2 : 2, 0.61, 0); 
                mesh.castShadow = true;
                scene.add(mesh);
                diceMeshes.push(mesh);
            }
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            const board = new THREE.Mesh(new THREE.BoxGeometry(30, 0.5, 30), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            board.receiveShadow = true; board.position.y = -0.25; boardGroup.add(board);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.8 });
            const addFrame = (w, h, d, x, z) => { const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), frameMat); m.position.set(x, 0.25, z); m.castShadow = true; m.receiveShadow = true; boardGroup.add(m); };
            addFrame(33, 1.5, 1.5, 0, -15.75); addFrame(33, 1.5, 1.5, 0, 15.75); addFrame(1.5, 1.5, 30, -15.75, 0); addFrame(1.5, 1.5, 30, 15.75, 0);
            const texLoader = new THREE.TextureLoader();
            const addCorner = (x, z, col, img, rot=0) => {
                const borderGeom = new THREE.PlaneGeometry(12, 12);
                const edges = new THREE.EdgesGeometry(borderGeom);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: col, linewidth: 3 }));
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.011, z);
                boardGroup.add(line);
                
                // Add thicker colored border frame
                const borderThickness = 0.4;
                const borderHeight = 0.15;
                const borderMat = new THREE.MeshStandardMaterial({ color: col });
                const addBorderSegment = (w, d, px, pz) => {
                    const seg = new THREE.Mesh(new THREE.BoxGeometry(w, borderHeight, d), borderMat);
                    seg.position.set(x + px, 0.08, z + pz);
                    boardGroup.add(seg);
                };
                addBorderSegment(12.4, borderThickness, 0, -6);
                addBorderSegment(12.4, borderThickness, 0, 6);
                addBorderSegment(borderThickness, 12.4, -6, 0);
                addBorderSegment(borderThickness, 12.4, 6, 0);
                if(img) texLoader.load(img, (t) => {
                    const im = new THREE.Mesh(new THREE.PlaneGeometry(11,11), new THREE.MeshStandardMaterial({map:t, transparent:true}));
                    im.rotation.set(-Math.PI/2, 0, rot); im.position.set(x, 0.012, z); boardGroup.add(im);
                }, undefined, () => {});
            };
            addCorner(-9,-9,0xff0000,'osimhen.jpg',-Math.PI/2); addCorner(9,-9,0x00ff00,'musa.jpg',Math.PI); addCorner(9,9,0xffff00,'nwabali.jpg',Math.PI/2); addCorner(-9,9,0x0000ff,'okocha.jpg',0);
            const addCirc = (x, z, c) => {
                const wx=(x-7)*2, wz=(z-7)*2;
                const f = new THREE.Mesh(new THREE.CircleGeometry(0.78,32), new THREE.MeshStandardMaterial({color:0xffffff})); f.rotation.x=-Math.PI/2; f.position.set(wx,0.02,wz); boardGroup.add(f);
                const r = new THREE.Mesh(new THREE.RingGeometry(0.55,0.78,32), new THREE.MeshStandardMaterial({color:c})); r.rotation.x=-Math.PI/2; r.position.set(wx,0.021,wz); boardGroup.add(r);
            };
            [[1,1],[4,1],[1,4],[4,4]].forEach(p=>addCirc(p[0],p[1],0xff0000)); [[10,1],[13,1],[10,4],[13,4]].forEach(p=>addCirc(p[0],p[1],0x00ff00)); [[10,10],[13,10],[10,13],[13,13]].forEach(p=>addCirc(p[0],p[1],0xffff00)); [[1,10],[4,10],[1,13],[4,13]].forEach(p=>addCirc(p[0],p[1],0x0000ff));
            const isHomeCol = (x,z) => HOME_PATHS.some(pth=>pth.some(p=>p[0]===x && p[1]===z));
            for(let x=0; x<15; x++) for(let z=0; z<15; z++) {
                if((x<=5&&z<=5)||(x<=5&&z>=9)||(x>=9&&z>=9)||(x>=9&&z<=5)) continue;
                let c = 0xeeeeee;
                if(BOARD_PATH.some(p=>p[0]===x && p[1]===z)) {
                    c = 0xffffff;
                    const idx = PATH_INDEX.get(coordKey(x,z));
                    PLAYER_START_POSITIONS.forEach((pos, i) => { if(pos===idx) c=PLAYERS[i].color; });
                }
                if(isHomeCol(x,z)) {
                    if(x===7 && z<7) c=0x00ff00; else if(z===7 && x<7) c=0xff0000; else if(x===7 && z>7) c=0x0000ff; else if(z===7 && x>7) c=0xffff00;
                }
                const sq = new THREE.Mesh(new THREE.PlaneGeometry(1.8,1.8), new THREE.MeshStandardMaterial({color:c})); sq.rotation.x=-Math.PI/2; sq.position.set((x-7)*2, 0.01, (z-7)*2); boardGroup.add(sq);
                const ln = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.PlaneGeometry(1.8,1.8)), new THREE.LineBasicMaterial({color:0x333333})); ln.rotation.x=-Math.PI/2; ln.position.set((x-7)*2, 0.02, (z-7)*2); boardGroup.add(ln);
            }
            const fin = new THREE.Mesh(new THREE.BoxGeometry(6,0.3,6), new THREE.MeshStandardMaterial({color:0xffffff}));
            texLoader.load('MY_LOGO.png', (t)=>{fin.material.map=t; fin.material.needsUpdate=true;}); fin.position.set(0,0.15,0); boardGroup.add(fin); 
            
            // Add directional arrows (hunting arrow style)
            const createArrow = (x, z, rotation) => {
                const arrowGroup = new THREE.Group();
                
                // Arrow shaft (brown wooden look)
                const shaft = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.9 })
                );
                shaft.rotation.z = Math.PI / 2;
                arrowGroup.add(shaft);
                
                // Arrowhead (metallic triangular tip)
                const headGeometry = new THREE.ConeGeometry(0.15, 0.3, 3);
                const arrowhead = new THREE.Mesh(
                    headGeometry,
                    new THREE.MeshStandardMaterial({ color: 0x4a4a4a, metalness: 0.7, roughness: 0.3 })
                );
                arrowhead.rotation.set(0, 0, -Math.PI / 2);
                arrowhead.position.x = 0.55;
                arrowGroup.add(arrowhead);
                
                // Fletching (feathers at the back)
                const fletchGeometry = new THREE.PlaneGeometry(0.15, 0.15);
                const fletchMaterial = new THREE.MeshStandardMaterial({ color: 0xff4444, side: THREE.DoubleSide });
                const fletch1 = new THREE.Mesh(fletchGeometry, fletchMaterial);
                fletch1.position.set(-0.35, 0.08, 0);
                const fletch2 = new THREE.Mesh(fletchGeometry, fletchMaterial);
                fletch2.position.set(-0.35, -0.08, 0);
                arrowGroup.add(fletch1, fletch2);
                
                arrowGroup.rotation.set(-Math.PI / 2, 0, rotation);
                arrowGroup.position.set((x - 7) * 2, 0.03, (z - 7) * 2);
                boardGroup.add(arrowGroup);
            };
            
            // Strategic arrow placements around the board path
            // Red path (left side going down)
            createArrow(1, 8, Math.PI / 2);
            createArrow(3, 8, 0);
            
            // Bottom path (going right)
            createArrow(6, 11, 0);
            createArrow(8, 11, -Math.PI / 2);
            
            // Green path (right side going up)
            createArrow(11, 6, -Math.PI / 2);
            createArrow(13, 6, Math.PI);
            
            // Top path (going left)
            createArrow(8, 3, Math.PI);
            createArrow(6, 3, Math.PI / 2);
            
            // Corner turns
            createArrow(5, 6, Math.PI * 3/4);
            createArrow(6, 9, Math.PI / 4);
            createArrow(9, 8, -Math.PI / 4);
            createArrow(8, 5, -Math.PI * 3/4);
            
            // Animate board entry
            boardGroup.position.y = -200;
            boardGroup.rotation.x = Math.PI / 2;
            let animProgress = 0;
            const animateBoard = () => {
                animProgress += 0.04;
                if (animProgress <= 1) {
                    if (animProgress <= 0.6) {
                        const t = animProgress / 0.6;
                        boardGroup.position.y = -200 + (210 * t);
                        boardGroup.rotation.x = (Math.PI / 2) * (1 - t) - (5 * Math.PI / 180) * t;
                    } else {
                        const t = (animProgress - 0.6) / 0.4;
                        boardGroup.position.y = 10 - (10 * t);
                        boardGroup.rotation.x = -(5 * Math.PI / 180) * (1 - t);
                    }
                    requestAnimationFrame(animateBoard);
                } else {
                    boardGroup.position.y = 0;
                    boardGroup.rotation.x = 0;
                }
            };
            animateBoard();
            
            scene.add(boardGroup);
        }
        function createPieces() {
            pieces = [];
            let pieceIndex = 0;
            activePlayers.forEach(pid => {
                for(let i=0; i<4; i++) {
                    const p = new GamePiece(pid, i);
                    const m = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4,0.8,16), new THREE.MeshStandardMaterial({color:PLAYERS[pid].color}));
                    m.castShadow=true; m.userData={piece:p};
                    const [x,z] = p.getWorldPosition();
                    const targetX = (x-7)*2, targetZ = (z-7)*2;
                    m.position.set(targetX, 0.5, targetZ);
                    p.mesh=m; boardGroup.add(m); pieces.push(p);
                    
                    // Animate piece entry with staggered delay
                    const delay = pieceIndex * 50;
                    m.scale.set(0, 0, 0);
                    m.position.y = -50;
                    setTimeout(() => {
                        let animProg = 0;
                        const animatePiece = () => {
                            animProg += 0.08;
                            if (animProg <= 1) {
                                if (animProg <= 0.5) {
                                    const t = animProg / 0.5;
                                    m.scale.set(1.2 * t, 1.2 * t, 1.2 * t);
                                    m.position.y = -50 + (40.5 * t);
                                } else {
                                    const t = (animProg - 0.5) / 0.5;
                                    m.scale.set(1.2 - (0.2 * t), 1.2 - (0.2 * t), 1.2 - (0.2 * t));
                                    m.position.y = -9.5 + (10 * t);
                                }
                                requestAnimationFrame(animatePiece);
                            } else {
                                m.scale.set(1, 1, 1);
                                m.position.y = 0.5;
                            }
                        };
                        animatePiece();
                    }, delay);
                    pieceIndex++;
                }
            });
        }
        function animate() { 
            requestAnimationFrame(animate);
            
            // 3D Selection: Hover detection
            if (selectablePieces.length > 0) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(selectablePieces.map(p => p.mesh));
                
                if (intersects.length > 0) {
                    const newHovered = intersects[0].object.userData.piece;
                    if (hoveredPiece !== newHovered) {
                        if (hoveredPiece) hoveredPiece.setHighlight('selectable');
                        hoveredPiece = newHovered;
                        hoveredPiece.setHighlight('hover');
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    if (hoveredPiece) {
                        hoveredPiece.setHighlight('selectable');
                        hoveredPiece = null;
                        document.body.style.cursor = 'default';
                    }
                }
            }
            
            renderer.render(scene, camera); 
        }
        function startGame() {
            playSound.click();
            audioCtx.resume();
            activePlayers = PLAYERS.slice(0, parseInt(document.getElementById('num-players').value)).map(p=>p.id);
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('dice-panel').style.display = 'block';
            createPieces(); updatePlayersList(); updateStatus(`${PLAYERS[currentPlayer].name}'s turn`); enableDiceRoll();
        }
        function updatePlayersList() {
            const l = document.getElementById('players-list'); l.innerHTML='';
            activePlayers.forEach(pid => {
                const c = document.createElement('div'); c.className=`player-card ${pid===currentPlayer?'active':''}`;
                c.innerHTML = `<div class="player-color" style="background:#${PLAYERS[pid].color.toString(16).padStart(6,'0')}"></div><div class="player-name">${PLAYERS[pid].name}</div><div class="player-pieces">${pieces.filter(p=>p.playerId===pid&&p.inFinish).length}/4 finished</div>`;
                l.appendChild(c);
            });
        }
        function updateStatus(t) { document.getElementById('status-text').textContent = t; }
        function enableDiceRoll() { const b=document.getElementById('roll-button'); b.disabled=false; b.onclick=rollDice; }
        function disableDiceRoll() { const b=document.getElementById('roll-button'); b.disabled=true; b.onclick=null; }
        
        // --- UPDATED: Animation Logic for Textured Dice ---
        function rollDice() {
            disableDiceRoll();
            playSound.diceRoll();
            diceValues = [Math.floor(Math.random()*6)+1, Math.floor(Math.random()*6)+1];
            
            diceMeshes.forEach((m, i) => {
                // Separate landing zones for each die to prevent overlap
                const targetX = i === 0 ? 
                    -4 - (Math.random() * 3) :  // Left die: -4 to -7
                    4 + (Math.random() * 3);    // Right die: 4 to 7
                const targetZ = (Math.random() - 0.5) * 6;
                const startPos = m.position.clone();
                let progress = 0;

                const rollAnim = () => {
                    progress += 0.04;
                    m.position.set(
                        startPos.x + (targetX - startPos.x) * progress,
                        0.6 + Math.abs(Math.sin(progress * Math.PI * 3)) * 4,
                        startPos.z + (targetZ - startPos.z) * progress
                    );
                    m.rotation.set(Math.random() * 10, Math.random() * 10, Math.random() * 10);
                    
                    if(progress < 1) requestAnimationFrame(rollAnim);
                    else {
                        // Rotations to bring the correct textured face to the top
                        // Mat Order: Right(1), Left(6), Top(2), Bottom(5), Front(3), Back(4)
                        const finalRots = {
                            1: [0, 0, Math.PI / 2],  // Right to Top
                            2: [0, 0, 0],            // Top stays Top
                            3: [-Math.PI / 2, 0, 0], // Front to Top
                            4: [Math.PI / 2, 0, 0],  // Back to Top
                            5: [Math.PI, 0, 0],      // Bottom to Top
                            6: [0, 0, -Math.PI / 2]  // Left to Top
                        };
                        const r = finalRots[diceValues[i]];
                        m.rotation.set(r[0], r[1], r[2]);
                        m.position.y = 0.61;
                        if(i === 1) setTimeout(handleDiceRoll, 500);
                    }
                };
                rollAnim();
            });
        }
        function handleDiceRoll() {
            availableDiceIndices=[0,1];
            const pPieces = pieces.filter(p=>p.playerId===currentPlayer);
            if(!pPieces.some(p=>p.canMove(diceValues[0])||p.canMove(diceValues[1]))) { updateStatus("No moves!"); setTimeout(nextTurn,1500); return; }
            updateStatus(`${PLAYERS[currentPlayer].name} rolled ${diceValues[0]} & ${diceValues[1]}`);
            const piecesOut = pPieces.filter(p => p.position !== -1 && !p.inFinish).length;
            
            // If a 6 is rolled, highlight all pieces that can move with 6
            if (diceValues.includes(6)) {
                const sixIndex = diceValues.indexOf(6);
                const movableWith6 = pPieces.filter(p => p.canMove(6));
                if (movableWith6.length > 0) {
                    selectedDieIndex = sixIndex;
                    updateStatus(`${PLAYERS[currentPlayer].name} - Select a piece to move with ${diceValues[sixIndex]}`);
                    enablePieceSelection(movableWith6);
                    return;
                }
            }
            
            if (piecesOut === 1) {
                if(pPieces.some(p=>p.canMove(diceValues[0]))) selectDie(0); else selectDie(1);
            }
        }
        function selectDie(idx) {
            if(!availableDiceIndices.includes(idx)) return; selectedDieIndex=idx;
            updateStatus(`${PLAYERS[currentPlayer].name} selected ${diceValues[idx]}`);
            const moves = pieces.filter(p=>p.playerId===currentPlayer && p.canMove(diceValues[idx]));
            
            // Clear all highlights
            pieces.forEach(p=>{if(p.mesh) p.setHighlight('none');});
            selectablePieces = [];
            hoveredPiece = null;
            
            if(moves.length>0) {
                if (moves.length === 1) selectPiece(moves[0], diceValues[idx], idx);
                else { enablePieceSelection(moves); }
            } else { updateStatus(`No moves for ${diceValues[idx]}`); if(availableDiceIndices.length===1) setTimeout(()=>finishTurn(false),1000); }
        }
        function enablePieceSelection(moves) {
            const cvs = document.getElementById('game-canvas');
            
            // Clean up previous selection state
            if(currentPieceClickListener) { 
                cvs.removeEventListener('click', currentPieceClickListener); 
                cvs.removeEventListener('touchstart', currentPieceClickListener); 
            }
            
            // 3D Selection: Set selectable pieces and highlight them
            selectablePieces = moves;
            hoveredPiece = null;
            moves.forEach(p => p.setHighlight('selectable'));
            
            currentPieceClickListener = (e) => {
                if(e.type==='touchstart') e.preventDefault();
                if(e.target.closest('.ui-panel') || e.target.closest('button')) return;
                
                const rect = cvs.getBoundingClientRect();
                const clientX = (e.changedTouches ? e.changedTouches[0].clientX : e.clientX);
                const clientY = (e.changedTouches ? e.changedTouches[0].clientY : e.clientY);
                
                raycaster.setFromCamera(
                    {x:((clientX-rect.left)/rect.width)*2-1, y:-((clientY-rect.top)/rect.height)*2+1}, 
                    camera
                );
                
                const hits = raycaster.intersectObjects(moves.map(p=>p.mesh));
                if(hits.length>0) { 
                    const piece = hits[0].object.userData.piece;
                    piece.setHighlight('selected');
                    
                    // Clean up selection state
                    selectablePieces = [];
                    hoveredPiece = null;
                    document.body.style.cursor = 'default';
                    
                    selectPiece(piece, diceValues[selectedDieIndex], selectedDieIndex); 
                    cvs.removeEventListener('click', currentPieceClickListener); 
                    cvs.removeEventListener('touchstart', currentPieceClickListener);
                    currentPieceClickListener = null;
                }
            };
            cvs.addEventListener('click', currentPieceClickListener); 
            cvs.addEventListener('touchstart', currentPieceClickListener, {passive:false});
        }
        function selectPiece(p, s, dieIdx) {
            if (dieIdx === undefined) dieIdx = selectedDieIndex;
            
            // Clear all highlights and selection state
            pieces.forEach(pc=>{if(pc.mesh) pc.setHighlight('none');});
            selectablePieces = [];
            hoveredPiece = null;
            document.body.style.cursor = 'default';
            
            playSound.pieceMove();
            p.move(s);
            let captured = false;
            if(p.position>=0 && p.position<TRACK_LENGTH) {
                const victim = pieces.find(v => v !== p && v.playerId !== p.playerId && v.position === p.position && v.position >= 0 && v.position < TRACK_LENGTH);
                if(victim) { 
                    playSound.capture();
                    victim.position = -1; victim.updateMeshPosition(); p.inFinish = true; p.position = FINISH_POS_BASE + (p.playerId * 10) + p.pieceId; p.updateMeshPosition(); captured = true; updateStatus("CAPTURED! Killer Retires!"); 
                }
            }
            availableDiceIndices = availableDiceIndices.filter(i=>i!==dieIdx);
            setTimeout(()=>{
                if(pieces.filter(pc=>pc.playerId===currentPlayer&&pc.inFinish).length===4) { 
                    playSound.win();
                    document.getElementById('winner-text').textContent=`${PLAYERS[currentPlayer].name} Wins!`; document.getElementById('winner-modal').classList.add('show'); return; 
                }
                if(availableDiceIndices.length>0) {
                    const rem = availableDiceIndices[0];
                    const pPieces = pieces.filter(pc=>pc.playerId===currentPlayer);
                    if(pPieces.some(pc=>pc.canMove(diceValues[rem]))) {
                        if (pPieces.filter(pc => pc.position !== -1 && !pc.inFinish).length === 1) selectDie(rem);
                        else selectDie(rem);
                    } else finishTurn(captured);
                } else finishTurn(captured);
            }, 600);
        }
        function finishTurn(bonus) {
            const isDoubleSix = (diceValues[0] === 6 && diceValues[1] === 6);
            if(isDoubleSix || bonus) { 
                playSound.bonus();
                updateStatus(bonus?"Killer Bonus! Roll Again!":"Double Six! Roll Again!"); 
                enableDiceRoll(); 
            } else { nextTurn(); }
        }
        function nextTurn() { currentPlayer = activePlayers[(activePlayers.indexOf(currentPlayer)+1)%activePlayers.length]; updatePlayersList(); updateStatus(`${PLAYERS[currentPlayer].name}'s turn`); enableDiceRoll(); }
        function restartGame() { playSound.click(); location.reload(); }
        function closeRules() { playSound.click(); document.getElementById('rules-modal').classList.remove('show'); }
        document.getElementById('start-button').addEventListener('click', startGame);
        document.getElementById('rules-button').addEventListener('click', ()=>{ playSound.click(); document.getElementById('rules-modal').classList.add('show'); });
        initThree();
    </script>
</body>
</html>
